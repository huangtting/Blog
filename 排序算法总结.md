https://www.cnblogs.com/onepixel/articles/7674659.html

# 十大算法比较
![sort](https://raw.githubusercontent.com/huangtting/Blog/master/images/sort.png)


# 冒泡排序(Bubble Sort)：
冒泡排序的基本思想是，对相邻的元素进行两两比较，大小相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。

## 时间复杂度
在平均和最坏的情况下都是O(n^2).

没有优化的情况下，最好情况下的时间复杂度依然是O(n^2)
```
for(int i=0;i<arr.length-1;i++){//外层循环控制排序趟数
　　for(int j=0;j<arr.length-1-i;j++){//内层循环控制每一趟排序多少次
　　   if(arr[j]>arr[j+1]){
　　　　　 int temp=arr[j];
　　　　   arr[j]=arr[j+1];
		  arr[j+1]=temp;
		}
	}
} 
```
冒泡优化：设置didSwap变量，可以使得在最好情况下的时间复杂度变为O(n)
```
public void bubbleSort(int arr[]) {
    boolean didSwap;
    for(int i = 0, len = arr.length; i < len - 1; i++) {
        didSwap = false;
        for(int j = 0; j < len - i - 1; j++) {
            if(arr[j + 1] < arr[j]) {
                swap(arr, j, j + 1);
                didSwap = true;
            }
        }
        if(didSwap == false)
            return;
    }    
}
```

# 选择排序(Selection Sort)：
从第0项开始寻找最小项与第0项交换，第二次从第一项开始寻找最小项与第一项交换...

```
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
} 
```
## 时间复杂度
在各种情况下时间复杂度都是O(n^2).

# 插入排序(Insertion Sort)
插入排序的基本思想是：假设前面部分的数组已有序。每步将一个待排序序列的数据插入到前面已经排序的序列中的适当位置，然后将之后的数据往后移动。直到全部数据插入完毕为止。 

```
function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];//将要插入的数据
        while (preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}
```
## 时间复杂度
在平均和最坏情况下都是O(n^2).
在最好情况下是O(n),如果数组有序，第二个while循环不会被执行。

# 希尔排序（Shell Sort）
希尔排序是插入排序的改进版，他将数组按照gap划分成不同的小组，对每一小组进行插入排序，然后不断缩小gap.

## 希尔增量
希尔增量是指希尔提出了一种冲破二次时间屏障的算法。
Donald Shell 提出了一种冲破二次时间屏障的算法Shellsort（希尔排序），在希尔排序中希尔给出了一组增量序列：ht = N / 2, h[k] = h[k+1] / 2，即 {N/2, (N / 2)/2, ..., 1}，这个序列就叫做希尔增量。

这个是编写希尔排序时最常用的序列，但却不是最好的。其余的增量序列还有Hibbard：{1, 3, ..., 2^k-1}，Sedgewick：{1, 5, 19, 41, 109...}该序列中的项或者是9*4^i - 9*2^i + 1或者是4^i - 3*2^i + 1。使用不同的增量对希尔排序的时间复杂度的改进将不一样，甚至一点小的改变都将引起算法性能剧烈的改变。

```
function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while (gap < len / 3) {          // 动态定义间隔序列
        gap = gap * 3 + 1;
    }
    for (gap; gap > 0; gap = Math.floor(gap / 3)) {
        for (var i = gap; i < len; i++) {
            temp = arr[i];
            for (var j = i-gap; j > 0 && arr[j]> temp; j-=gap) {
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = temp;
        }
    }
    return arr;
}
```

## 时间复杂度
希尔排序是基于插入排序，所以在最坏情况下是O(n^2)，在最好情况下是O(n)（和插入排序一直），在平均情况下可以达到O(n^1.3)。

# 归并排序（Merge Sort）
归并排序采用了分治法，将序列分成两份，在对每份序列分成两份，直到不可再分为止，然后对每份序列采取同样的方式进行排序合并。

```
function mergeSort(arr) {  // 采用自上而下的递归方法
    var len = arr.length;
    if (len < 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
//合并函数，将两个序列中较小的数放进result中，返回有序的result数组
function merge(left, right) {
    var result = [];
 
    while (left.length>0 && right.length>0) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
 
    while (left.length)
        result.push(left.shift());
 
    while (right.length)
        result.push(right.shift());
 
    return result;
}
```
# 时间复杂度
合并两个序列的函数的复杂度是O(n)，

快速排序：快速排序是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此实现整个数据变成有序序列。
```
public static void quickSort(int[] array, int left, int right) {
    if (left < right) {
        int pivot = array[left];
        int low = left;
        int high = right;
        while (low < high) {
            while (low < high && array[high] >= pivot) {
                high--;
            }
			
            while (low < high && array[low] <= pivot) {
                low++;
            }
            Swap(array[high] , array[low]);
        }
        array[low] = pivot;
        quickSort(array, left, low - 1);
        quickSort(array, low + 1, right);
    }
}
```

## 插入排序：



## 堆排序
堆排序适合大量数据的排序
